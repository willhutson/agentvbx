/**
 * Unified file store abstraction.
 *
 * The desktop app connects users' local files, Obsidian vaults, and cloud
 * storage into a single searchable file layer. This lets AI agents access
 * user context — "summarize the report on my desktop", "check my Obsidian
 * notes about project X", "find the spreadsheet in Drive" — all through
 * WhatsApp or any channel.
 *
 * Store types:
 * - local: directories on the user's filesystem (Desktop, Documents, Downloads)
 * - obsidian: Obsidian vault with frontmatter parsing and link resolution
 * - cloud: wrapper around IntegrationAdapter (Google Drive, Dropbox, OneDrive)
 *
 * Artifact versioning:
 * - Artifacts generated by AI go through draft → pending → approved → final
 * - Each version is tracked with content hash and metadata
 * - Revisions triggered via WhatsApp ("revise the intro") create new versions
 */

import { createLogger } from '../logger.js';

const logger = createLogger('file-store');

// ─── Core Types ─────────────────────────────────────────────────────────────

export interface FileEntry {
  /** Unique path within the store (relative). */
  path: string;
  /** Display name. */
  name: string;
  /** MIME type. */
  mime_type: string;
  /** File size in bytes. */
  size_bytes: number;
  /** Last modified ISO timestamp. */
  modified_at: string;
  /** Is a directory/folder. */
  is_directory: boolean;
  /** Which store this file belongs to. */
  store_id: string;
  /** Store-specific metadata (Obsidian frontmatter, Drive metadata, etc.). */
  metadata?: Record<string, unknown>;
}

export interface FileContent {
  entry: FileEntry;
  /** Raw content as buffer. */
  data: Buffer;
  /** Text content (if text-based file). */
  text?: string;
  /** Encoding used. */
  encoding?: string;
}

export type FileStoreType = 'local' | 'obsidian' | 'cloud';

export interface FileStoreConfig {
  id: string;
  name: string;
  type: FileStoreType;
  /** Root path (local/obsidian) or provider ID (cloud). */
  root: string;
  /** File patterns to include (glob). Defaults to all. */
  include?: string[];
  /** File patterns to exclude (glob). */
  exclude?: string[];
  /** Max file size to index (bytes). Defaults to 50MB. */
  max_file_size?: number;
  /** Whether this store is read-only. */
  read_only?: boolean;
}

/**
 * Unified interface for all file stores.
 */
export interface FileStore {
  readonly id: string;
  readonly name: string;
  readonly type: FileStoreType;

  /** List files at a path (or root if not specified). */
  list(path?: string): Promise<FileEntry[]>;

  /** Read file content. */
  read(path: string): Promise<FileContent | null>;

  /** Write/update file content. Returns the updated entry. */
  write(path: string, content: Buffer | string): Promise<FileEntry>;

  /** Search files by name or content query. */
  search(query: string): Promise<FileEntry[]>;

  /** Check if the store is accessible. */
  isConnected(): Promise<boolean>;

  /** Get total file count and size. */
  stats(): Promise<{ files: number; total_bytes: number }>;
}

// ─── Local File Store ───────────────────────────────────────────────────────

export class LocalFileStore implements FileStore {
  readonly id: string;
  readonly name: string;
  readonly type: FileStoreType = 'local';
  private config: FileStoreConfig;

  constructor(config: FileStoreConfig) {
    this.id = config.id;
    this.name = config.name;
    this.config = config;
  }

  async list(path?: string): Promise<FileEntry[]> {
    const { readdir, stat } = await import('node:fs/promises');
    const { join, extname } = await import('node:path');

    const targetDir = path ? join(this.config.root, path) : this.config.root;
    const entries: FileEntry[] = [];

    try {
      const items = await readdir(targetDir, { withFileTypes: true });

      for (const item of items) {
        // Skip hidden files and excluded patterns
        if (item.name.startsWith('.')) continue;
        if (this.isExcluded(item.name)) continue;

        const fullPath = join(targetDir, item.name);
        const relativePath = path ? `${path}/${item.name}` : item.name;

        try {
          const stats = await stat(fullPath);

          if (stats.size > (this.config.max_file_size ?? 50 * 1024 * 1024)) continue;

          entries.push({
            path: relativePath,
            name: item.name,
            mime_type: item.isDirectory() ? 'inode/directory' : this.guessMimeType(item.name),
            size_bytes: stats.size,
            modified_at: stats.mtime.toISOString(),
            is_directory: item.isDirectory(),
            store_id: this.id,
          });
        } catch {
          // Skip files we can't stat
        }
      }
    } catch (err) {
      logger.warn({ err, path: targetDir }, 'Failed to list directory');
    }

    return entries;
  }

  async read(path: string): Promise<FileContent | null> {
    const { readFile, stat } = await import('node:fs/promises');
    const { join } = await import('node:path');

    const fullPath = join(this.config.root, path);

    try {
      const [data, stats] = await Promise.all([
        readFile(fullPath),
        stat(fullPath),
      ]);

      const entry: FileEntry = {
        path,
        name: path.split('/').pop() ?? path,
        mime_type: this.guessMimeType(path),
        size_bytes: stats.size,
        modified_at: stats.mtime.toISOString(),
        is_directory: false,
        store_id: this.id,
      };

      const isText = this.isTextFile(path);

      return {
        entry,
        data,
        text: isText ? data.toString('utf-8') : undefined,
        encoding: isText ? 'utf-8' : undefined,
      };
    } catch {
      return null;
    }
  }

  async write(path: string, content: Buffer | string): Promise<FileEntry> {
    if (this.config.read_only) {
      throw new Error(`Store ${this.id} is read-only`);
    }

    const { writeFile, mkdir, stat } = await import('node:fs/promises');
    const { join, dirname } = await import('node:path');

    const fullPath = join(this.config.root, path);
    await mkdir(dirname(fullPath), { recursive: true });
    await writeFile(fullPath, content);

    const stats = await stat(fullPath);

    return {
      path,
      name: path.split('/').pop() ?? path,
      mime_type: this.guessMimeType(path),
      size_bytes: stats.size,
      modified_at: stats.mtime.toISOString(),
      is_directory: false,
      store_id: this.id,
    };
  }

  async search(query: string): Promise<FileEntry[]> {
    const results: FileEntry[] = [];
    const lowerQuery = query.toLowerCase();

    const searchDir = async (path?: string) => {
      const entries = await this.list(path);
      for (const entry of entries) {
        if (entry.name.toLowerCase().includes(lowerQuery)) {
          results.push(entry);
        }
        if (entry.is_directory && results.length < 100) {
          await searchDir(entry.path);
        }
      }
    };

    await searchDir();
    return results;
  }

  async isConnected(): Promise<boolean> {
    const { access } = await import('node:fs/promises');
    try {
      await access(this.config.root);
      return true;
    } catch {
      return false;
    }
  }

  async stats(): Promise<{ files: number; total_bytes: number }> {
    let files = 0;
    let totalBytes = 0;

    const countDir = async (path?: string) => {
      const entries = await this.list(path);
      for (const entry of entries) {
        if (entry.is_directory) {
          await countDir(entry.path);
        } else {
          files++;
          totalBytes += entry.size_bytes;
        }
      }
    };

    await countDir();
    return { files, total_bytes: totalBytes };
  }

  private isExcluded(name: string): boolean {
    if (!this.config.exclude) return false;
    return this.config.exclude.some((pattern) => {
      if (pattern.startsWith('*.')) {
        return name.endsWith(pattern.slice(1));
      }
      return name === pattern;
    });
  }

  private isTextFile(path: string): boolean {
    const textExts = [
      '.txt', '.md', '.json', '.yaml', '.yml', '.csv', '.xml', '.html',
      '.js', '.ts', '.py', '.rb', '.go', '.rs', '.java', '.sh', '.css',
      '.toml', '.ini', '.cfg', '.env', '.log', '.sql',
    ];
    const ext = path.substring(path.lastIndexOf('.'));
    return textExts.includes(ext.toLowerCase());
  }

  private guessMimeType(filename: string): string {
    const ext = filename.substring(filename.lastIndexOf('.')).toLowerCase();
    const map: Record<string, string> = {
      '.md': 'text/markdown', '.txt': 'text/plain', '.json': 'application/json',
      '.yaml': 'text/yaml', '.yml': 'text/yaml', '.csv': 'text/csv',
      '.pdf': 'application/pdf', '.png': 'image/png', '.jpg': 'image/jpeg',
      '.jpeg': 'image/jpeg', '.gif': 'image/gif', '.svg': 'image/svg+xml',
      '.mp4': 'video/mp4', '.mp3': 'audio/mpeg', '.wav': 'audio/wav',
      '.doc': 'application/msword', '.html': 'text/html', '.xml': 'text/xml',
      '.js': 'text/javascript', '.ts': 'text/typescript', '.py': 'text/x-python',
      '.docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
      '.xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      '.pptx': 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
    };
    return map[ext] ?? 'application/octet-stream';
  }
}

// ─── Obsidian Vault Store ───────────────────────────────────────────────────

export interface ObsidianNote extends FileEntry {
  /** Parsed YAML frontmatter. */
  frontmatter?: Record<string, unknown>;
  /** Internal links found in the note ([[link]]). */
  links: string[];
  /** Tags found in the note (#tag). */
  tags: string[];
}

export class ObsidianStore implements FileStore {
  readonly id: string;
  readonly name: string;
  readonly type: FileStoreType = 'obsidian';
  private config: FileStoreConfig;
  private localStore: LocalFileStore;

  constructor(config: FileStoreConfig) {
    this.id = config.id;
    this.name = config.name;
    this.config = { ...config, exclude: [...(config.exclude ?? []), '.obsidian', '.trash'] };
    this.localStore = new LocalFileStore(this.config);
  }

  async list(path?: string): Promise<FileEntry[]> {
    return this.localStore.list(path);
  }

  async read(path: string): Promise<FileContent | null> {
    const content = await this.localStore.read(path);
    if (!content) return null;

    // Enrich markdown files with Obsidian metadata
    if (path.endsWith('.md') && content.text) {
      const parsed = this.parseObsidianNote(path, content.text);
      content.entry.metadata = {
        frontmatter: parsed.frontmatter,
        links: parsed.links,
        tags: parsed.tags,
      };
    }

    return content;
  }

  async write(path: string, content: Buffer | string): Promise<FileEntry> {
    return this.localStore.write(path, content);
  }

  async search(query: string): Promise<FileEntry[]> {
    // Search both filenames and content for Obsidian vaults
    const nameResults = await this.localStore.search(query);
    const contentResults = await this.searchContent(query);

    // Merge and deduplicate
    const seen = new Set(nameResults.map((e) => e.path));
    const merged = [...nameResults];
    for (const result of contentResults) {
      if (!seen.has(result.path)) {
        merged.push(result);
        seen.add(result.path);
      }
    }

    return merged;
  }

  async isConnected(): Promise<boolean> {
    const { access } = await import('node:fs/promises');
    const { join } = await import('node:path');

    try {
      // Verify .obsidian directory exists (confirms it's a vault)
      await access(join(this.config.root, '.obsidian'));
      return true;
    } catch {
      return false;
    }
  }

  async stats(): Promise<{ files: number; total_bytes: number }> {
    return this.localStore.stats();
  }

  /**
   * List all notes with their parsed Obsidian metadata.
   */
  async listNotes(path?: string): Promise<ObsidianNote[]> {
    const entries = await this.list(path);
    const notes: ObsidianNote[] = [];

    for (const entry of entries) {
      if (entry.is_directory) continue;
      if (!entry.name.endsWith('.md')) continue;

      const content = await this.read(entry.path);
      if (content?.text) {
        const parsed = this.parseObsidianNote(entry.path, content.text);
        notes.push({
          ...entry,
          frontmatter: parsed.frontmatter,
          links: parsed.links,
          tags: parsed.tags,
        });
      }
    }

    return notes;
  }

  /**
   * Resolve an Obsidian wiki-link ([[note name]]) to a file path.
   */
  async resolveLink(linkText: string): Promise<FileEntry | null> {
    // Strip any heading references
    const noteName = linkText.split('#')[0].split('|')[0].trim();
    const results = await this.search(noteName);

    // Prefer exact match, then partial match
    const exact = results.find((e) => {
      const name = e.name.replace('.md', '');
      return name === noteName;
    });

    return exact ?? results[0] ?? null;
  }

  // ─── Internal ─────────────────────────────────────────────────────────

  private parseObsidianNote(path: string, text: string): {
    frontmatter?: Record<string, unknown>;
    links: string[];
    tags: string[];
  } {
    let frontmatter: Record<string, unknown> | undefined;
    const links: string[] = [];
    const tags: string[] = [];

    // Parse YAML frontmatter
    if (text.startsWith('---')) {
      const endIndex = text.indexOf('---', 3);
      if (endIndex !== -1) {
        const yamlBlock = text.substring(3, endIndex).trim();
        try {
          // Simple YAML key-value parsing (no full YAML parser dep needed)
          frontmatter = {};
          for (const line of yamlBlock.split('\n')) {
            const colonIdx = line.indexOf(':');
            if (colonIdx > 0) {
              const key = line.substring(0, colonIdx).trim();
              const value = line.substring(colonIdx + 1).trim();
              frontmatter[key] = value;
            }
          }
        } catch {
          // Malformed frontmatter
        }
      }
    }

    // Extract wiki-links [[link]]
    const linkRegex = /\[\[([^\]]+)\]\]/g;
    let match;
    while ((match = linkRegex.exec(text)) !== null) {
      links.push(match[1]);
    }

    // Extract tags #tag
    const tagRegex = /(?:^|\s)#([a-zA-Z][\w/-]*)/g;
    while ((match = tagRegex.exec(text)) !== null) {
      tags.push(match[1]);
    }

    return { frontmatter, links, tags };
  }

  private async searchContent(query: string): Promise<FileEntry[]> {
    const results: FileEntry[] = [];
    const lowerQuery = query.toLowerCase();

    const searchDir = async (path?: string) => {
      const entries = await this.list(path);
      for (const entry of entries) {
        if (entry.is_directory) {
          if (results.length < 50) await searchDir(entry.path);
          continue;
        }

        if (!entry.name.endsWith('.md')) continue;

        const content = await this.localStore.read(entry.path);
        if (content?.text?.toLowerCase().includes(lowerQuery)) {
          results.push(entry);
        }
      }
    };

    await searchDir();
    return results;
  }
}

// ─── Cloud File Store ───────────────────────────────────────────────────────

/**
 * Subset of IntegrationAdapter needed for file operations.
 */
export interface CloudAdapterLike {
  readonly id: string;
  readonly name: string;
  isConnected(): Promise<boolean>;
  list(params?: Record<string, unknown>): Promise<Array<{
    id: string;
    name: string;
    mime_type: string;
    size_bytes?: number;
    url?: string;
    created_at?: string;
    modified_at?: string;
    metadata?: Record<string, unknown>;
  }>>;
  read(id: string): Promise<{
    id: string;
    name: string;
    mime_type: string;
    metadata?: Record<string, unknown>;
  } | null>;
}

export class CloudFileStore implements FileStore {
  readonly id: string;
  readonly name: string;
  readonly type: FileStoreType = 'cloud';
  private adapter: CloudAdapterLike;

  constructor(id: string, name: string, adapter: CloudAdapterLike) {
    this.id = id;
    this.name = name;
    this.adapter = adapter;
  }

  async list(path?: string): Promise<FileEntry[]> {
    const params: Record<string, unknown> = {};
    if (path) params.folder_id = path;

    const items = await this.adapter.list(params);

    return items.map((item) => ({
      path: item.id,
      name: item.name,
      mime_type: item.mime_type,
      size_bytes: item.size_bytes ?? 0,
      modified_at: item.modified_at ?? new Date().toISOString(),
      is_directory: item.mime_type === 'application/vnd.google-apps.folder',
      store_id: this.id,
      metadata: { ...item.metadata, url: item.url },
    }));
  }

  async read(path: string): Promise<FileContent | null> {
    const item = await this.adapter.read(path);
    if (!item) return null;

    return {
      entry: {
        path,
        name: item.name,
        mime_type: item.mime_type,
        size_bytes: 0,
        modified_at: new Date().toISOString(),
        is_directory: false,
        store_id: this.id,
        metadata: item.metadata,
      },
      data: Buffer.alloc(0), // Cloud files are fetched on demand
    };
  }

  async write(_path: string, _content: Buffer | string): Promise<FileEntry> {
    throw new Error('Use IntegrationAdapter.create() for cloud file uploads');
  }

  async search(query: string): Promise<FileEntry[]> {
    const items = await this.adapter.list({ search: query });
    return items.map((item) => ({
      path: item.id,
      name: item.name,
      mime_type: item.mime_type,
      size_bytes: item.size_bytes ?? 0,
      modified_at: item.modified_at ?? new Date().toISOString(),
      is_directory: false,
      store_id: this.id,
    }));
  }

  async isConnected(): Promise<boolean> {
    return this.adapter.isConnected();
  }

  async stats(): Promise<{ files: number; total_bytes: number }> {
    const items = await this.adapter.list();
    const totalBytes = items.reduce((sum, item) => sum + (item.size_bytes ?? 0), 0);
    return { files: items.length, total_bytes: totalBytes };
  }
}

// ─── File Store Manager ─────────────────────────────────────────────────────

/**
 * Manages all connected file stores for a tenant.
 * This is the single entry point for file access across local, Obsidian, and cloud.
 */
export class FileStoreManager {
  private stores: Map<string, FileStore> = new Map();

  register(store: FileStore): void {
    this.stores.set(store.id, store);
    logger.info({ id: store.id, name: store.name, type: store.type }, 'File store registered');
  }

  get(id: string): FileStore | undefined {
    return this.stores.get(id);
  }

  /**
   * Search across ALL connected stores.
   */
  async searchAll(query: string): Promise<FileEntry[]> {
    const results: FileEntry[] = [];

    await Promise.all(
      Array.from(this.stores.values()).map(async (store) => {
        try {
          if (await store.isConnected()) {
            const storeResults = await store.search(query);
            results.push(...storeResults);
          }
        } catch (err) {
          logger.warn({ err, store: store.id }, 'Search failed for store');
        }
      }),
    );

    // Sort by modified_at (most recent first)
    results.sort((a, b) => new Date(b.modified_at).getTime() - new Date(a.modified_at).getTime());
    return results;
  }

  /**
   * Read a file from any connected store.
   */
  async readFrom(storeId: string, path: string): Promise<FileContent | null> {
    const store = this.stores.get(storeId);
    if (!store) return null;
    return store.read(path);
  }

  /**
   * List all connected stores with their status.
   */
  async listStores(): Promise<Array<{ id: string; name: string; type: FileStoreType; connected: boolean }>> {
    const result = [];
    for (const store of this.stores.values()) {
      const connected = await store.isConnected();
      result.push({ id: store.id, name: store.name, type: store.type, connected });
    }
    return result;
  }

  /**
   * Get aggregate stats across all stores.
   */
  async allStats(): Promise<Record<string, { files: number; total_bytes: number }>> {
    const result: Record<string, { files: number; total_bytes: number }> = {};
    for (const store of this.stores.values()) {
      try {
        if (await store.isConnected()) {
          result[store.id] = await store.stats();
        }
      } catch {
        result[store.id] = { files: 0, total_bytes: 0 };
      }
    }
    return result;
  }
}
