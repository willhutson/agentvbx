/**
 * Artifact versioning and draft lifecycle.
 *
 * AI-generated artifacts go through a lifecycle:
 *   draft → pending_review → revision → approved → delivered
 *
 * Users provide feedback through WhatsApp — text messages, voice notes,
 * reactions to specific parts — often fragmented across multiple messages
 * over time. The feedback accumulator collects these fragments, unifies
 * them into a coherent revision request, and triggers a new version.
 *
 * Example flow:
 * 1. AI generates "Q4 Report" → v1 (draft)
 * 2. User receives preview on WhatsApp → status: pending_review
 * 3. User sends text: "the intro is too long"
 * 4. User sends voice note 2 min later: "also fix the revenue chart"
 * 5. User sends text: "and add a section on partnerships"
 * 6. Feedback window closes (timeout or explicit "that's it")
 * 7. Feedback fragments unified → single revision prompt
 * 8. AI revises → v2 (draft) → user reviews again or approves
 */

import { createLogger } from '../logger.js';
import type { Channel } from '../types.js';

const logger = createLogger('artifact-versioning');

// ─── Version Types ──────────────────────────────────────────────────────────

export type ArtifactStatus =
  | 'draft'            // Just generated by AI, not yet reviewed
  | 'pending_review'   // Sent to user, waiting for feedback
  | 'collecting_feedback' // User is actively providing feedback (fragments incoming)
  | 'revision'         // Feedback collected, being revised by AI
  | 'approved'         // User approved, ready for delivery
  | 'delivered'        // Uploaded to cloud + user notified
  | 'archived';        // Superseded or no longer needed

export interface ArtifactVersion {
  /** Version number (1, 2, 3...). */
  version: number;
  /** Status at the time of this version. */
  status: ArtifactStatus;
  /** SHA-256 hash of the content for dedup/comparison. */
  content_hash: string;
  /** When this version was created. */
  created_at: string;
  /** Who created it — agent name or 'user'. */
  created_by: string;
  /** Optional version note. */
  comment?: string;
  /** Local file path for this version's content. */
  local_path: string;
  /** Cloud URL if this version was uploaded. */
  cloud_url?: string;
  /** The unified feedback that prompted this version (for v2+). */
  revision_prompt?: string;
}

// ─── Feedback Types ─────────────────────────────────────────────────────────

export type FeedbackType = 'text' | 'voice_note' | 'reaction' | 'image_annotation';

export interface FeedbackFragment {
  /** Unique ID. */
  id: string;
  /** The artifact this feedback is about. */
  artifact_id: string;
  /** Type of feedback. */
  type: FeedbackType;
  /** Raw content — text message, voice note transcript, etc. */
  content: string;
  /** Original voice note/media URL if applicable. */
  media_url?: string;
  /** Which channel the feedback came from. */
  channel: Channel;
  /** When the feedback was received. */
  received_at: string;
  /** Which part of the artifact this references (if identifiable). */
  section_ref?: string;
  /** Order within the feedback session. */
  sequence: number;
}

export interface UnifiedFeedback {
  /** The artifact being revised. */
  artifact_id: string;
  /** All fragments that were collected. */
  fragments: FeedbackFragment[];
  /** The unified, coherent revision prompt (assembled from fragments). */
  revision_prompt: string;
  /** How many fragments were unified. */
  fragment_count: number;
  /** Time span of feedback collection. */
  started_at: string;
  ended_at: string;
  /** Whether feedback was closed by timeout or explicit user signal. */
  close_reason: 'timeout' | 'explicit' | 'max_fragments';
}

// ─── Version Manager ────────────────────────────────────────────────────────

export interface VersionedArtifact {
  artifact_id: string;
  tenant_id: string;
  filename: string;
  current_version: number;
  status: ArtifactStatus;
  versions: ArtifactVersion[];
  /** Active feedback fragments being collected. */
  pending_feedback: FeedbackFragment[];
  /** Completed feedback sessions. */
  feedback_history: UnifiedFeedback[];
  created_at: string;
  updated_at: string;
}

export class VersionManager {
  private artifacts: Map<string, VersionedArtifact> = new Map();

  /**
   * Register a new artifact (v1 draft).
   */
  createVersionedArtifact(
    artifactId: string,
    tenantId: string,
    filename: string,
    localPath: string,
    createdBy: string,
    contentHash: string,
  ): VersionedArtifact {
    const now = new Date().toISOString();

    const versioned: VersionedArtifact = {
      artifact_id: artifactId,
      tenant_id: tenantId,
      filename,
      current_version: 1,
      status: 'draft',
      versions: [
        {
          version: 1,
          status: 'draft',
          content_hash: contentHash,
          created_at: now,
          created_by: createdBy,
          local_path: localPath,
        },
      ],
      pending_feedback: [],
      feedback_history: [],
      created_at: now,
      updated_at: now,
    };

    this.artifacts.set(artifactId, versioned);
    logger.info({ artifactId, filename, createdBy }, 'Versioned artifact created (v1 draft)');
    return versioned;
  }

  /**
   * Transition artifact to pending_review (sent to user).
   */
  markSentForReview(artifactId: string): void {
    const artifact = this.getOrThrow(artifactId);
    artifact.status = 'pending_review';
    artifact.updatedAt();
    logger.info({ artifactId }, 'Artifact sent for review');
  }

  /**
   * Add a feedback fragment. Automatically enters collecting_feedback state.
   */
  addFeedback(artifactId: string, fragment: Omit<FeedbackFragment, 'id' | 'sequence'>): FeedbackFragment {
    const artifact = this.getOrThrow(artifactId);

    // Transition to collecting state on first fragment
    if (artifact.status === 'pending_review') {
      artifact.status = 'collecting_feedback';
    }

    const fullFragment: FeedbackFragment = {
      ...fragment,
      id: `fb_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`,
      sequence: artifact.pending_feedback.length + 1,
    };

    artifact.pending_feedback.push(fullFragment);
    artifact.updatedAt();

    logger.info({
      artifactId,
      fragmentId: fullFragment.id,
      type: fragment.type,
      count: artifact.pending_feedback.length,
    }, 'Feedback fragment added');

    return fullFragment;
  }

  /**
   * Close the feedback window and unify fragments into a revision prompt.
   * Returns the unified feedback for the AI to process.
   */
  closeFeedback(artifactId: string, reason: UnifiedFeedback['close_reason']): UnifiedFeedback {
    const artifact = this.getOrThrow(artifactId);

    if (artifact.pending_feedback.length === 0) {
      throw new Error(`No pending feedback for artifact ${artifactId}`);
    }

    const unified: UnifiedFeedback = {
      artifact_id: artifactId,
      fragments: [...artifact.pending_feedback],
      revision_prompt: this.unifyFragments(artifact.pending_feedback),
      fragment_count: artifact.pending_feedback.length,
      started_at: artifact.pending_feedback[0].received_at,
      ended_at: artifact.pending_feedback[artifact.pending_feedback.length - 1].received_at,
      close_reason: reason,
    };

    artifact.feedback_history.push(unified);
    artifact.pending_feedback = [];
    artifact.status = 'revision';
    artifact.updatedAt();

    logger.info({
      artifactId,
      fragmentCount: unified.fragment_count,
      reason,
    }, 'Feedback unified for revision');

    return unified;
  }

  /**
   * Add a new version after AI revision.
   */
  addVersion(
    artifactId: string,
    localPath: string,
    contentHash: string,
    createdBy: string,
    revisionPrompt?: string,
  ): ArtifactVersion {
    const artifact = this.getOrThrow(artifactId);

    const version: ArtifactVersion = {
      version: artifact.current_version + 1,
      status: 'draft',
      content_hash: contentHash,
      created_at: new Date().toISOString(),
      created_by: createdBy,
      local_path: localPath,
      revision_prompt: revisionPrompt,
    };

    artifact.versions.push(version);
    artifact.current_version = version.version;
    artifact.status = 'draft';
    artifact.updatedAt();

    logger.info({
      artifactId,
      version: version.version,
      createdBy,
    }, 'New artifact version created');

    return version;
  }

  /**
   * Approve the current version for delivery.
   */
  approve(artifactId: string): void {
    const artifact = this.getOrThrow(artifactId);
    artifact.status = 'approved';
    const currentVersion = artifact.versions[artifact.versions.length - 1];
    currentVersion.status = 'approved';
    artifact.updatedAt();
    logger.info({ artifactId, version: artifact.current_version }, 'Artifact approved');
  }

  /**
   * Mark as delivered (uploaded to cloud).
   */
  markDelivered(artifactId: string, cloudUrl: string): void {
    const artifact = this.getOrThrow(artifactId);
    artifact.status = 'delivered';
    const currentVersion = artifact.versions[artifact.versions.length - 1];
    currentVersion.status = 'delivered';
    currentVersion.cloud_url = cloudUrl;
    artifact.updatedAt();
    logger.info({ artifactId, version: artifact.current_version, cloudUrl }, 'Artifact delivered');
  }

  /**
   * Get a versioned artifact.
   */
  get(artifactId: string): VersionedArtifact | undefined {
    return this.artifacts.get(artifactId);
  }

  /**
   * Get a specific version's content path.
   */
  getVersionPath(artifactId: string, version: number): string | undefined {
    const artifact = this.artifacts.get(artifactId);
    if (!artifact) return undefined;
    return artifact.versions.find((v) => v.version === version)?.local_path;
  }

  /**
   * List all artifacts for a tenant, optionally filtered by status.
   */
  listForTenant(tenantId: string, status?: ArtifactStatus): VersionedArtifact[] {
    return Array.from(this.artifacts.values())
      .filter((a) => a.tenant_id === tenantId)
      .filter((a) => !status || a.status === status);
  }

  /**
   * Check if an artifact has pending feedback that might need closing.
   * Used for timeout-based feedback window management.
   */
  hasPendingFeedback(artifactId: string): boolean {
    const artifact = this.artifacts.get(artifactId);
    return artifact ? artifact.pending_feedback.length > 0 : false;
  }

  /**
   * Get the time since the last feedback fragment (for timeout detection).
   */
  timeSinceLastFeedback(artifactId: string): number | null {
    const artifact = this.artifacts.get(artifactId);
    if (!artifact || artifact.pending_feedback.length === 0) return null;

    const last = artifact.pending_feedback[artifact.pending_feedback.length - 1];
    return Date.now() - new Date(last.received_at).getTime();
  }

  // ─── Internal ─────────────────────────────────────────────────────────

  private getOrThrow(artifactId: string): VersionedArtifact & { updatedAt: () => void } {
    const artifact = this.artifacts.get(artifactId);
    if (!artifact) throw new Error(`Artifact not found: ${artifactId}`);
    return Object.assign(artifact, {
      updatedAt: () => { artifact.updated_at = new Date().toISOString(); },
    });
  }

  /**
   * Unify feedback fragments into a coherent revision prompt.
   *
   * Handles:
   * - Text messages (direct feedback)
   * - Voice note transcripts (may be conversational, need cleaning)
   * - Multiple fragments about different sections
   * - Progressive reactions (first impression → deeper thoughts)
   */
  private unifyFragments(fragments: FeedbackFragment[]): string {
    if (fragments.length === 1) {
      return this.cleanFragment(fragments[0]);
    }

    // Group by section reference if available
    const bySection = new Map<string, FeedbackFragment[]>();
    const general: FeedbackFragment[] = [];

    for (const fragment of fragments) {
      if (fragment.section_ref) {
        const existing = bySection.get(fragment.section_ref) ?? [];
        existing.push(fragment);
        bySection.set(fragment.section_ref, existing);
      } else {
        general.push(fragment);
      }
    }

    const parts: string[] = [];

    // General feedback first
    if (general.length > 0) {
      const generalText = general.map((f) => this.cleanFragment(f)).join(' ');
      parts.push(`General feedback: ${generalText}`);
    }

    // Section-specific feedback
    for (const [section, sectionFragments] of bySection) {
      const sectionText = sectionFragments.map((f) => this.cleanFragment(f)).join(' ');
      parts.push(`Regarding "${section}": ${sectionText}`);
    }

    return `Please revise the document with the following feedback:\n\n${parts.join('\n\n')}`;
  }

  /**
   * Clean a single fragment for inclusion in a revision prompt.
   * Voice notes especially need cleaning — they're conversational and may
   * include filler words, self-corrections, and tangential thoughts.
   */
  private cleanFragment(fragment: FeedbackFragment): string {
    let text = fragment.content.trim();

    if (fragment.type === 'voice_note') {
      // Voice transcripts often have filler — prefix to give AI context
      text = `[Voice note] ${text}`;
    }

    if (fragment.type === 'reaction') {
      text = `[Reaction] ${text}`;
    }

    return text;
  }
}
